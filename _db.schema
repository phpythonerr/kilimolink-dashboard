-- Database Schema for Authentication & Authorization System

-- Roles table (for basic role assignments)
CREATE TABLE roles (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  name TEXT NOT NULL UNIQUE,
  description TEXT,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Permissions table (defines all available permissions)
CREATE TABLE permissions (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  name TEXT NOT NULL UNIQUE,
  description TEXT,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Role-Permission mapping table
CREATE TABLE role_permissions (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  role_id UUID NOT NULL REFERENCES roles(id) ON DELETE CASCADE,
  permission_id UUID NOT NULL REFERENCES permissions(id) ON DELETE CASCADE,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  UNIQUE (role_id, permission_id)
);

-- User Role assignments
CREATE TABLE user_roles (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  role_id UUID NOT NULL REFERENCES roles(id) ON DELETE CASCADE,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  UNIQUE (user_id, role_id)
);

-- Direct user permission assignments (override/extend role permissions)
CREATE TABLE user_permissions (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  permission_name TEXT NOT NULL,
  granted BOOLEAN NOT NULL DEFAULT TRUE,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  UNIQUE (user_id, permission_name)
);

-- Access logs for audit trail
CREATE TABLE access_logs (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  path TEXT NOT NULL,
  method TEXT NOT NULL,
  ip_address TEXT,
  timestamp TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  user_agent TEXT
);

-- Security logs for suspicious activities
CREATE TABLE security_logs (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE,
  action TEXT NOT NULL,
  resource TEXT,
  ip_address TEXT,
  user_agent TEXT,
  required_permissions TEXT[],
  details JSONB,
  timestamp TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Trigger to update timestamps
CREATE OR REPLACE FUNCTION update_timestamp()
RETURNS TRIGGER AS $$
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Apply update timestamp triggers
CREATE TRIGGER update_roles_timestamp
BEFORE UPDATE ON roles
FOR EACH ROW EXECUTE PROCEDURE update_timestamp();

CREATE TRIGGER update_user_roles_timestamp
BEFORE UPDATE ON user_roles
FOR EACH ROW EXECUTE PROCEDURE update_timestamp();

CREATE TRIGGER update_user_permissions_timestamp
BEFORE UPDATE ON user_permissions
FOR EACH ROW EXECUTE PROCEDURE update_timestamp();

-- Create RLS policies for security
-- Only authenticated users can access these tables

-- Roles table policies
ALTER TABLE roles ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Roles viewable by authenticated users with admin.users.view permission" 
ON roles FOR SELECT 
USING (
  EXISTS (
    SELECT 1 FROM user_permissions 
    WHERE user_id = auth.uid() 
    AND (permission_name = 'admin.users.view' OR permission_name = 'admin.superuser')
    AND granted = TRUE
  )
);

-- Only users with admin.users.edit can modify roles
CREATE POLICY "Roles editable by users with admin.users.edit permission" 
ON roles FOR INSERT 
WITH CHECK (
  EXISTS (
    SELECT 1 FROM user_permissions 
    WHERE user_id = auth.uid() 
    AND (permission_name = 'admin.users.edit' OR permission_name = 'admin.superuser')
    AND granted = TRUE
  )
);

CREATE POLICY "Roles updatable by users with admin.users.edit permission" 
ON roles FOR UPDATE
USING (
  EXISTS (
    SELECT 1 FROM user_permissions 
    WHERE user_id = auth.uid() 
    AND (permission_name = 'admin.users.edit' OR permission_name = 'admin.superuser')
    AND granted = TRUE
  )
);

-- Similar policies for other tables (abbreviated for brevity)
ALTER TABLE permissions ENABLE ROW LEVEL SECURITY;
ALTER TABLE role_permissions ENABLE ROW LEVEL SECURITY;
ALTER TABLE user_roles ENABLE ROW LEVEL SECURITY;
ALTER TABLE user_permissions ENABLE ROW LEVEL SECURITY;

-- Access logs viewable only by security admins
ALTER TABLE access_logs ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Access logs viewable by security admins" 
ON access_logs FOR SELECT 
USING (
  EXISTS (
    SELECT 1 FROM user_permissions 
    WHERE user_id = auth.uid() 
    AND (permission_name = 'admin.security.view' OR permission_name = 'admin.superuser')
    AND granted = TRUE
  )
);

-- Security logs viewable only by security admins
ALTER TABLE security_logs ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Security logs viewable by security admins" 
ON security_logs FOR SELECT 
USING (
  EXISTS (
    SELECT 1 FROM user_permissions 
    WHERE user_id = auth.uid() 
    AND (permission_name = 'admin.security.view' OR permission_name = 'admin.superuser')
    AND granted = TRUE
  )
);

-- Insert policy for access_logs (middleware needs to insert)
CREATE POLICY "Access logs can be inserted by authenticated users" 
ON access_logs FOR INSERT 
WITH CHECK (auth.role() = 'authenticated');

-- Insert policy for security_logs (middleware needs to insert)
CREATE POLICY "Security logs can be inserted by authenticated users" 
ON security_logs FOR INSERT 
WITH CHECK (auth.role() = 'authenticated');

-- Some default data to get started
INSERT INTO roles (name, description) VALUES
('Admin', 'Full system access'),
('Manager', 'Can manage projects and reports'),
('User', 'Basic user access'),
('Analyst', 'Can view analytics and reports');

INSERT INTO permissions (name, description) VALUES
('admin.superuser', 'Full system access'),
('admin.access', 'Access to admin area'),
('admin.users.view', 'View user information'),
('admin.users.edit', 'Edit user information'),
('admin.security.view', 'View security logs'),
('dashboard.access', 'Access to dashboard'),
('dashboard.analytics.view', 'View analytics'),
('dashboard.reports.view', 'View reports'),
('dashboard.reports.create', 'Create reports'),
('projects.access', 'Access to projects'),
('projects.create', 'Create projects'),
('projects.edit', 'Edit projects');

-- Link roles to permissions
INSERT INTO role_permissions (role_id, permission_id)
SELECT 
  (SELECT id FROM roles WHERE name = 'Admin'),
  (SELECT id FROM permissions WHERE name = 'admin.superuser');

INSERT INTO role_permissions (role_id, permission_id)
SELECT 
  (SELECT id FROM roles WHERE name = 'Manager'),
  id
FROM permissions 
WHERE name IN ('dashboard.access', 'dashboard.analytics.view', 'dashboard.reports.view', 
               'dashboard.reports.create', 'projects.access', 'projects.create', 'projects.edit');

INSERT INTO role_permissions (role_id, permission_id)
SELECT 
  (SELECT id FROM roles WHERE name = 'User'),
  id
FROM permissions 
WHERE name IN ('dashboard.access', 'projects.access');

INSERT INTO role_permissions (role_id, permission_id)
SELECT 
  (SELECT id FROM roles WHERE name = 'Analyst'),
  id
FROM permissions 
WHERE name IN ('dashboard.access', 'dashboard.analytics.view', 'dashboard.reports.view');

-- Create functions to help manage permissions

-- Function to get all permissions for a user (from roles and direct assignments)
CREATE OR REPLACE FUNCTION get_user_permissions(user_id UUID)
RETURNS TABLE (permission_name TEXT) AS $$
BEGIN
  RETURN QUERY
    -- Get permissions from roles
    SELECT DISTINCT p.name
    FROM permissions p
    JOIN role_permissions rp ON p.id = rp.permission_id
    JOIN user_roles ur ON rp.role_id = ur.role_id
    WHERE ur.user_id = get_user_permissions.user_id
    
    UNION
    
    -- Get directly assigned permissions (where granted = true)
    SELECT up.permission_name
    FROM user_permissions up
    WHERE up.user_id = get_user_permissions.user_id
    AND up.granted = TRUE;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Function to check if a user has a specific permission
CREATE OR REPLACE FUNCTION has_permission(user_id UUID, required_permission TEXT)
RETURNS BOOLEAN AS $$
DECLARE
  has_perm BOOLEAN;
BEGIN
  -- Check for superuser first
  SELECT EXISTS (
    SELECT 1 FROM user_permissions
    WHERE user_id = has_permission.user_id
    AND permission_name = 'admin.superuser'
    AND granted = TRUE
  ) INTO has_perm;
  
  IF has_perm THEN
    RETURN TRUE;
  END IF;
  
  -- Check for the specific permission
  SELECT EXISTS (
    SELECT 1 FROM get_user_permissions(has_permission.user_id)
    WHERE permission_name = has_permission.required_permission
  ) INTO has_perm;
  
  RETURN has_perm;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;